{
  "version": 3,
  "sources": ["../../src/utils.ts", "../../src/errors.ts", "../../src/span.ts", "../../src/transaction.ts", "../../src/idletransaction.ts", "../../src/hubextensions.ts", "../../@sentry/tracing/esm/integrations/index.js", "../../@sentry/src/buildPolyfills/_optionalChain.ts", "../../src/integrations/node/utils/node-utils.ts", "../../src/integrations/node/express.ts", "../../src/integrations/node/postgres.ts", "../../src/integrations/node/mysql.ts", "../../src/integrations/node/mongo.ts", "../../src/integrations/node/prisma.ts", "../../src/integrations/node/graphql.ts", "../../src/integrations/node/apollo.ts", "../../src/browser/types.ts", "../../src/browser/backgroundtab.ts", "../../src/browser/web-vitals/lib/bindReporter.ts", "../../src/browser/web-vitals/lib/generateUniqueID.ts", "../../src/browser/web-vitals/lib/getNavigationEntry.ts", "../../src/browser/web-vitals/lib/getActivationStart.ts", "../../src/browser/web-vitals/lib/initMetric.ts", "../../src/browser/web-vitals/lib/observe.ts", "../../src/browser/web-vitals/lib/onHidden.ts", "../../src/browser/web-vitals/getCLS.ts", "../../src/browser/web-vitals/lib/getVisibilityWatcher.ts", "../../src/browser/web-vitals/getFID.ts", "../../src/browser/web-vitals/getLCP.ts", "../../src/browser/metrics/utils.ts", "../../src/browser/metrics/index.ts", "../../src/browser/request.ts", "../../src/browser/router.ts", "../../src/browser/browsertracing.ts", "../../src/spanstatus.ts", "../../src/index.ts"],
  "sourcesContent": ["import type { Hub } from '@sentry/core';\nimport { getCurrentHub, hasTracingEnabled as _hasTracingEnabled } from '@sentry/core';\nimport type { Options, Transaction } from '@sentry/types';\n\n/**\n * The `extractTraceparentData` function and `TRACEPARENT_REGEXP` constant used\n * to be declared in this file. It was later moved into `@sentry/utils` as part of a\n * move to remove `@sentry/tracing` dependencies from `@sentry/node` (`extractTraceparentData`\n * is the only tracing function used by `@sentry/node`).\n *\n * These exports are kept here for backwards compatability's sake.\n *\n * TODO(v7): Reorganize these exports\n *\n * See https://github.com/getsentry/sentry-javascript/issues/4642 for more details.\n */\nexport { TRACEPARENT_REGEXP, extractTraceparentData } from '@sentry/utils';\n\n/**\n * Determines if tracing is currently enabled.\n *\n * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.\n * @deprecated This export has moved to `@sentry/core`. This export will be removed from `@sentry/tracing` in v8.\n */\nexport function hasTracingEnabled(\n  maybeOptions?: Pick<Options, 'tracesSampleRate' | 'tracesSampler' | 'enableTracing'> | undefined,\n): boolean {\n  return _hasTracingEnabled(maybeOptions);\n}\n\n/** Grabs active transaction off scope, if any */\nexport function getActiveTransaction<T extends Transaction>(maybeHub?: Hub): T | undefined {\n  const hub = maybeHub || getCurrentHub();\n  const scope = hub.getScope();\n  return scope && (scope.getTransaction() as T | undefined);\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nexport function msToSec(time: number): number {\n  return time / 1000;\n}\n\n/**\n * Converts from seconds to milliseconds\n * @param time time in seconds\n */\nexport function secToMs(time: number): number {\n  return time * 1000;\n}\n\n// so it can be used in manual instrumentation without necessitating a hard dependency on @sentry/utils\nexport { stripUrlQueryAndFragment } from '@sentry/utils';\n", "import { addInstrumentationHandler, logger } from '@sentry/utils';\n\nimport type { SpanStatusType } from './span';\nimport { getActiveTransaction } from './utils';\n\n/**\n * Configures global error listeners\n */\nexport function registerErrorInstrumentation(): void {\n  addInstrumentationHandler('error', errorCallback);\n  addInstrumentationHandler('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback(): void {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const status: SpanStatusType = 'internal_error';\n    __DEBUG_BUILD__ && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n", "/* eslint-disable max-lines */\nimport type {\n  Instrumenter,\n  Primitive,\n  Span as SpanInterface,\n  SpanContext,\n  TraceContext,\n  Transaction,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger, timestampWithMs, uuid4 } from '@sentry/utils';\n\n/**\n * Keeps track of finished spans for a given transaction\n * @internal\n * @hideconstructor\n * @hidden\n */\nexport class SpanRecorder {\n  public spans: Span[] = [];\n\n  private readonly _maxlen: number;\n\n  public constructor(maxlen: number = 1000) {\n    this._maxlen = maxlen;\n  }\n\n  /**\n   * This is just so that we don't run out of memory while recording a lot\n   * of spans. At some point we just stop and flush out the start of the\n   * trace tree (i.e.the first n spans with the smallest\n   * start_timestamp).\n   */\n  public add(span: Span): void {\n    if (this.spans.length > this._maxlen) {\n      span.spanRecorder = undefined;\n    } else {\n      this.spans.push(span);\n    }\n  }\n}\n\n/**\n * Span contains all data about a span\n */\nexport class Span implements SpanInterface {\n  /**\n   * @inheritDoc\n   */\n  public traceId: string = uuid4();\n\n  /**\n   * @inheritDoc\n   */\n  public spanId: string = uuid4().substring(16);\n\n  /**\n   * @inheritDoc\n   */\n  public parentSpanId?: string;\n\n  /**\n   * Internal keeper of the status\n   */\n  public status?: SpanStatusType | string;\n\n  /**\n   * @inheritDoc\n   */\n  public sampled?: boolean;\n\n  /**\n   * Timestamp in seconds when the span was created.\n   */\n  public startTimestamp: number = timestampWithMs();\n\n  /**\n   * Timestamp in seconds when the span ended.\n   */\n  public endTimestamp?: number;\n\n  /**\n   * @inheritDoc\n   */\n  public op?: string;\n\n  /**\n   * @inheritDoc\n   */\n  public description?: string;\n\n  /**\n   * @inheritDoc\n   */\n  public tags: { [key: string]: Primitive } = {};\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public data: { [key: string]: any } = {};\n\n  /**\n   * List of spans that were finalized\n   */\n  public spanRecorder?: SpanRecorder;\n\n  /**\n   * @inheritDoc\n   */\n  public transaction?: Transaction;\n\n  /**\n   * The instrumenter that created this span.\n   */\n  public instrumenter: Instrumenter = 'sentry';\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startTransaction()`\n   * or call `startChild()` on an existing span.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(spanContext?: SpanContext) {\n    if (!spanContext) {\n      return this;\n    }\n    if (spanContext.traceId) {\n      this.traceId = spanContext.traceId;\n    }\n    if (spanContext.spanId) {\n      this.spanId = spanContext.spanId;\n    }\n    if (spanContext.parentSpanId) {\n      this.parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this.sampled = spanContext.sampled;\n    }\n    if (spanContext.op) {\n      this.op = spanContext.op;\n    }\n    if (spanContext.description) {\n      this.description = spanContext.description;\n    }\n    if (spanContext.data) {\n      this.data = spanContext.data;\n    }\n    if (spanContext.tags) {\n      this.tags = spanContext.tags;\n    }\n    if (spanContext.status) {\n      this.status = spanContext.status;\n    }\n    if (spanContext.startTimestamp) {\n      this.startTimestamp = spanContext.startTimestamp;\n    }\n    if (spanContext.endTimestamp) {\n      this.endTimestamp = spanContext.endTimestamp;\n    }\n    if (spanContext.instrumenter) {\n      this.instrumenter = spanContext.instrumenter;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startChild(\n    spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'sampled' | 'traceId' | 'parentSpanId'>>,\n  ): Span {\n    const childSpan = new Span({\n      ...spanContext,\n      parentSpanId: this.spanId,\n      sampled: this.sampled,\n      traceId: this.traceId,\n    });\n\n    childSpan.spanRecorder = this.spanRecorder;\n    if (childSpan.spanRecorder) {\n      childSpan.spanRecorder.add(childSpan);\n    }\n\n    childSpan.transaction = this.transaction;\n\n    if (__DEBUG_BUILD__ && childSpan.transaction) {\n      const opStr = (spanContext && spanContext.op) || '< unknown op >';\n      const nameStr = childSpan.transaction.name || '< unknown name >';\n      const idStr = childSpan.transaction.spanId;\n\n      const logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;\n      childSpan.transaction.metadata.spanMetadata[childSpan.spanId] = { logMessage };\n      logger.log(logMessage);\n    }\n\n    return childSpan;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTag(key: string, value: Primitive): this {\n    this.tags = { ...this.tags, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public setData(key: string, value: any): this {\n    this.data = { ...this.data, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setStatus(value: SpanStatusType): this {\n    this.status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setHttpStatus(httpStatus: number): this {\n    this.setTag('http.status_code', String(httpStatus));\n    const spanStatus = spanStatusfromHttpCode(httpStatus);\n    if (spanStatus !== 'unknown_error') {\n      this.setStatus(spanStatus);\n    }\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public isSuccess(): boolean {\n    return this.status === 'ok';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): void {\n    if (\n      __DEBUG_BUILD__ &&\n      // Don't call this for transactions\n      this.transaction &&\n      this.transaction.spanId !== this.spanId\n    ) {\n      const { logMessage } = this.transaction.metadata.spanMetadata[this.spanId];\n      if (logMessage) {\n        logger.log((logMessage as string).replace('Starting', 'Finishing'));\n      }\n    }\n\n    this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toTraceparent(): string {\n    let sampledString = '';\n    if (this.sampled !== undefined) {\n      sampledString = this.sampled ? '-1' : '-0';\n    }\n    return `${this.traceId}-${this.spanId}${sampledString}`;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toContext(): SpanContext {\n    return dropUndefinedKeys({\n      data: this.data,\n      description: this.description,\n      endTimestamp: this.endTimestamp,\n      op: this.op,\n      parentSpanId: this.parentSpanId,\n      sampled: this.sampled,\n      spanId: this.spanId,\n      startTimestamp: this.startTimestamp,\n      status: this.status,\n      tags: this.tags,\n      traceId: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public updateWithContext(spanContext: SpanContext): this {\n    this.data = spanContext.data || {};\n    this.description = spanContext.description;\n    this.endTimestamp = spanContext.endTimestamp;\n    this.op = spanContext.op;\n    this.parentSpanId = spanContext.parentSpanId;\n    this.sampled = spanContext.sampled;\n    this.spanId = spanContext.spanId || this.spanId;\n    this.startTimestamp = spanContext.startTimestamp || this.startTimestamp;\n    this.status = spanContext.status;\n    this.tags = spanContext.tags || {};\n    this.traceId = spanContext.traceId || this.traceId;\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTraceContext(): TraceContext {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      trace_id: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toJSON(): {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data?: { [key: string]: any };\n    description?: string;\n    op?: string;\n    parent_span_id?: string;\n    span_id: string;\n    start_timestamp: number;\n    status?: string;\n    tags?: { [key: string]: Primitive };\n    timestamp?: number;\n    trace_id: string;\n  } {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      start_timestamp: this.startTimestamp,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      timestamp: this.endTimestamp,\n      trace_id: this.traceId,\n    });\n  }\n}\n\nexport type SpanStatusType =\n  /** The operation completed successfully. */\n  | 'ok'\n  /** Deadline expired before operation could complete. */\n  | 'deadline_exceeded'\n  /** 401 Unauthorized (actually does mean unauthenticated according to RFC 7235) */\n  | 'unauthenticated'\n  /** 403 Forbidden */\n  | 'permission_denied'\n  /** 404 Not Found. Some requested entity (file or directory) was not found. */\n  | 'not_found'\n  /** 429 Too Many Requests */\n  | 'resource_exhausted'\n  /** Client specified an invalid argument. 4xx. */\n  | 'invalid_argument'\n  /** 501 Not Implemented */\n  | 'unimplemented'\n  /** 503 Service Unavailable */\n  | 'unavailable'\n  /** Other/generic 5xx. */\n  | 'internal_error'\n  /** Unknown. Any non-standard HTTP status code. */\n  | 'unknown_error'\n  /** The operation was cancelled (typically by the user). */\n  | 'cancelled'\n  /** Already exists (409) */\n  | 'already_exists'\n  /** Operation was rejected because the system is not in a state required for the operation's */\n  | 'failed_precondition'\n  /** The operation was aborted, typically due to a concurrency issue. */\n  | 'aborted'\n  /** Operation was attempted past the valid range. */\n  | 'out_of_range'\n  /** Unrecoverable data loss or corruption */\n  | 'data_loss';\n\n/**\n * Converts a HTTP status code into a {@link SpanStatusType}.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\nexport function spanStatusfromHttpCode(httpStatus: number): SpanStatusType {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return 'ok';\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return 'unauthenticated';\n      case 403:\n        return 'permission_denied';\n      case 404:\n        return 'not_found';\n      case 409:\n        return 'already_exists';\n      case 413:\n        return 'failed_precondition';\n      case 429:\n        return 'resource_exhausted';\n      default:\n        return 'invalid_argument';\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return 'unimplemented';\n      case 503:\n        return 'unavailable';\n      case 504:\n        return 'deadline_exceeded';\n      default:\n        return 'internal_error';\n    }\n  }\n\n  return 'unknown_error';\n}\n", "import type { Hub } from '@sentry/core';\nimport { getCurrentHub } from '@sentry/core';\nimport type {\n  Context,\n  Contexts,\n  DynamicSamplingContext,\n  Event,\n  Measurements,\n  MeasurementUnit,\n  Transaction as TransactionInterface,\n  TransactionContext,\n  TransactionMetadata,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\n\nimport { Span as SpanClass, SpanRecorder } from './span';\n\n/** JSDoc */\nexport class Transaction extends SpanClass implements TransactionInterface {\n  public metadata: TransactionMetadata;\n\n  /**\n   * The reference to the current hub.\n   */\n  public readonly _hub: Hub;\n\n  private _name: string;\n\n  private _measurements: Measurements = {};\n\n  private _contexts: Contexts = {};\n\n  private _trimEnd?: boolean;\n\n  private _frozenDynamicSamplingContext: Readonly<Partial<DynamicSamplingContext>> | undefined = undefined;\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(transactionContext: TransactionContext, hub?: Hub) {\n    super(transactionContext);\n\n    this._hub = hub || getCurrentHub();\n\n    this._name = transactionContext.name || '';\n\n    this.metadata = {\n      source: 'custom',\n      ...transactionContext.metadata,\n      spanMetadata: {},\n    };\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n\n    // If Dynamic Sampling Context is provided during the creation of the transaction, we freeze it as it usually means\n    // there is incoming Dynamic Sampling Context. (Either through an incoming request, a baggage meta-tag, or other means)\n    const incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;\n    if (incomingDynamicSamplingContext) {\n      // We shallow copy this in case anything writes to the original reference of the passed in `dynamicSamplingContext`\n      this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };\n    }\n  }\n\n  /** Getter for `name` property */\n  public get name(): string {\n    return this._name;\n  }\n\n  /** Setter for `name` property, which also sets `source` as custom */\n  public set name(newName: string) {\n    this.setName(newName);\n  }\n\n  /**\n   * JSDoc\n   */\n  public setName(name: string, source: TransactionMetadata['source'] = 'custom'): void {\n    this._name = name;\n    this.metadata.source = source;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  public initSpanRecorder(maxlen: number = 1000): void {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setContext(key: string, context: Context | null): void {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setMeasurement(name: string, value: number, unit: MeasurementUnit = ''): void {\n    this._measurements[name] = { value, unit };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setMetadata(newMetadata: Partial<TransactionMetadata>): void {\n    this.metadata = { ...this.metadata, ...newMetadata };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): string | undefined {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      __DEBUG_BUILD__ && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      __DEBUG_BUILD__ && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n      const client = this._hub.getClient();\n      if (client) {\n        client.recordDroppedEvent('sample_rate', 'transaction');\n      }\n\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev: SpanClass, current: SpanClass) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    const metadata = this.metadata;\n\n    const transaction: Event = {\n      contexts: {\n        ...this._contexts,\n        // We don't want to override trace context\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        ...metadata,\n        dynamicSamplingContext: this.getDynamicSamplingContext(),\n      },\n      ...(metadata.source && {\n        transaction_info: {\n          source: metadata.source,\n        },\n      }),\n    };\n\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      __DEBUG_BUILD__ &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction',\n          JSON.stringify(this._measurements, undefined, 2),\n        );\n      transaction.measurements = this._measurements;\n    }\n\n    __DEBUG_BUILD__ && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toContext(): TransactionContext {\n    const spanContext = super.toContext();\n\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public updateWithContext(transactionContext: TransactionContext): this {\n    super.updateWithContext(transactionContext);\n\n    this.name = transactionContext.name || '';\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @experimental\n   */\n  public getDynamicSamplingContext(): Readonly<Partial<DynamicSamplingContext>> {\n    if (this._frozenDynamicSamplingContext) {\n      return this._frozenDynamicSamplingContext;\n    }\n\n    const hub: Hub = this._hub || getCurrentHub();\n    const client = hub && hub.getClient();\n\n    if (!client) return {};\n\n    const { environment, release } = client.getOptions() || {};\n    const { publicKey: public_key } = client.getDsn() || {};\n\n    const maybeSampleRate = this.metadata.sampleRate;\n    const sample_rate = maybeSampleRate !== undefined ? maybeSampleRate.toString() : undefined;\n\n    const scope = hub.getScope();\n    const { segment: user_segment } = (scope && scope.getUser()) || {};\n\n    const source = this.metadata.source;\n\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    const transaction = source && source !== 'url' ? this.name : undefined;\n\n    const dsc = dropUndefinedKeys({\n      environment,\n      release,\n      transaction,\n      user_segment,\n      public_key,\n      trace_id: this.traceId,\n      sample_rate,\n    });\n\n    // Uncomment if we want to make DSC immutable\n    // this._frozenDynamicSamplingContext = dsc;\n\n    return dsc;\n  }\n}\n", "/* eslint-disable max-lines */\nimport type { Hub } from '@sentry/core';\nimport type { TransactionContext } from '@sentry/types';\nimport { logger, timestampWithMs } from '@sentry/utils';\n\nimport type { Span } from './span';\nimport { SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const DEFAULT_IDLE_TIMEOUT = 1000;\nexport const DEFAULT_FINAL_TIMEOUT = 30000;\nexport const DEFAULT_HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string,\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  private _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n    private readonly _idleTimeout: number = DEFAULT_IDLE_TIMEOUT,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n    private readonly _finalTimeout: number = DEFAULT_FINAL_TIMEOUT,\n    private readonly _heartbeatInterval: number = DEFAULT_HEARTBEAT_INTERVAL,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      __DEBUG_BUILD__ && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._startIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampWithMs()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      __DEBUG_BUILD__ &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          __DEBUG_BUILD__ &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          __DEBUG_BUILD__ &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      __DEBUG_BUILD__ && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      __DEBUG_BUILD__ && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      __DEBUG_BUILD__ && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n  private _cancelIdleTimeout(): void {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Creates an idletimeout\n   */\n  private _startIdleTimeout(endTimestamp?: Parameters<IdleTransaction['finish']>[0]): void {\n    this._cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    this._cancelIdleTimeout();\n    __DEBUG_BUILD__ && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      __DEBUG_BUILD__ && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      __DEBUG_BUILD__ && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    __DEBUG_BUILD__ && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub: Hub): void {\n  const scope = hub.getScope();\n  if (scope) {\n    const transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\n", "import type { Hub } from '@sentry/core';\nimport { getMainCarrier, hasTracingEnabled } from '@sentry/core';\nimport type {\n  ClientOptions,\n  CustomSamplingContext,\n  Integration,\n  IntegrationClass,\n  Options,\n  SamplingContext,\n  TransactionContext,\n} from '@sentry/types';\nimport { dynamicRequire, isNaN, isNodeEnv, loadModule, logger } from '@sentry/utils';\n\nimport { registerErrorInstrumentation } from './errors';\nimport { IdleTransaction } from './idletransaction';\nimport { Transaction } from './transaction';\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders(this: Hub): { [key: string]: string } {\n  const scope = this.getScope();\n  if (scope) {\n    const span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * Makes a sampling decision for the given transaction and stores it on the transaction.\n *\n * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n *\n * @param transaction: The transaction needing a sampling decision\n * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`\n * @param samplingContext: Default and user-provided data which may be used to help make the decision\n *\n * @returns The given transaction with its `sampled` value set\n */\nfunction sample<T extends Transaction>(\n  transaction: T,\n  options: Pick<Options, 'tracesSampleRate' | 'tracesSampler' | 'enableTracing'>,\n  samplingContext: SamplingContext,\n): T {\n  // nothing to do if tracing is not enabled\n  if (!hasTracingEnabled(options)) {\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that\n  if (transaction.sampled !== undefined) {\n    transaction.setMetadata({\n      sampleRate: Number(transaction.sampled),\n    });\n    return transaction;\n  }\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` nor `enableTracing` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler(samplingContext);\n    transaction.setMetadata({\n      sampleRate: Number(sampleRate),\n    });\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else if (typeof options.tracesSampleRate !== 'undefined') {\n    sampleRate = options.tracesSampleRate;\n    transaction.setMetadata({\n      sampleRate: Number(sampleRate),\n    });\n  } else {\n    // When `enableTracing === true`, we use a sample rate of 100%\n    sampleRate = 1;\n    transaction.setMetadata({\n      sampleRate,\n    });\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(sampleRate)) {\n    __DEBUG_BUILD__ && logger.warn('[Tracing] Discarding transaction because of invalid sample rate.');\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!sampleRate) {\n    __DEBUG_BUILD__ &&\n      logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  transaction.sampled = Math.random() < (sampleRate as number | boolean);\n\n  // if we're not going to keep it, we're done\n  if (!transaction.sampled) {\n    __DEBUG_BUILD__ &&\n      logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n    return transaction;\n  }\n\n  __DEBUG_BUILD__ && logger.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);\n  return transaction;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if (isNaN(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {\n    __DEBUG_BUILD__ &&\n      logger.warn(\n        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    __DEBUG_BUILD__ &&\n      logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a new transaction and adds a sampling decision if it doesn't yet have one.\n *\n * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if\n * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an\n * \"extension method.\"\n *\n * @param this: The Hub starting the transaction\n * @param transactionContext: Data used to configure the transaction\n * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)\n *\n * @returns The new transaction\n *\n * @see {@link Hub.startTransaction}\n */\nfunction _startTransaction(\n  this: Hub,\n  transactionContext: TransactionContext,\n  customSamplingContext?: CustomSamplingContext,\n): Transaction {\n  const client = this.getClient();\n  const options: Partial<ClientOptions> = (client && client.getOptions()) || {};\n\n  const configInstrumenter = options.instrumenter || 'sentry';\n  const transactionInstrumenter = transactionContext.instrumenter || 'sentry';\n\n  if (configInstrumenter !== transactionInstrumenter) {\n    __DEBUG_BUILD__ &&\n      logger.error(\n        `A transaction was started with instrumenter=\\`${transactionInstrumenter}\\`, but the SDK is configured with the \\`${configInstrumenter}\\` instrumenter.\nThe transaction will not be sampled. Please use the ${configInstrumenter} instrumentation to start transactions.`,\n      );\n\n    transactionContext.sampled = false;\n  }\n\n  let transaction = new Transaction(transactionContext, this);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans as number));\n  }\n  return transaction;\n}\n\n/**\n * Create new idle transaction.\n */\nexport function startIdleTransaction(\n  hub: Hub,\n  transactionContext: TransactionContext,\n  idleTimeout: number,\n  finalTimeout: number,\n  onScope?: boolean,\n  customSamplingContext?: CustomSamplingContext,\n  heartbeatInterval?: number,\n): IdleTransaction {\n  const client = hub.getClient();\n  const options: Partial<ClientOptions> = (client && client.getOptions()) || {};\n\n  let transaction = new IdleTransaction(transactionContext, hub, idleTimeout, finalTimeout, heartbeatInterval, onScope);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans as number));\n  }\n  return transaction;\n}\n\n/**\n * @private\n */\nexport function _addTracingExtensions(): void {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  if (!carrier.__SENTRY__.extensions.startTransaction) {\n    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;\n  }\n  if (!carrier.__SENTRY__.extensions.traceHeaders) {\n    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n  }\n}\n\n/**\n * @private\n */\nfunction _autoloadDatabaseIntegrations(): void {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n\n  const packageToIntegrationMapping: Record<string, () => Integration> = {\n    mongodb() {\n      const integration = dynamicRequire(module, './integrations/node/mongo') as {\n        Mongo: IntegrationClass<Integration>;\n      };\n      return new integration.Mongo();\n    },\n    mongoose() {\n      const integration = dynamicRequire(module, './integrations/node/mongo') as {\n        Mongo: IntegrationClass<Integration>;\n      };\n      return new integration.Mongo({ mongoose: true });\n    },\n    mysql() {\n      const integration = dynamicRequire(module, './integrations/node/mysql') as {\n        Mysql: IntegrationClass<Integration>;\n      };\n      return new integration.Mysql();\n    },\n    pg() {\n      const integration = dynamicRequire(module, './integrations/node/postgres') as {\n        Postgres: IntegrationClass<Integration>;\n      };\n      return new integration.Postgres();\n    },\n  };\n\n  const mappedPackages = Object.keys(packageToIntegrationMapping)\n    .filter(moduleName => !!loadModule(moduleName))\n    .map(pkg => {\n      try {\n        return packageToIntegrationMapping[pkg]();\n      } catch (e) {\n        return undefined;\n      }\n    })\n    .filter(p => p) as Integration[];\n\n  if (mappedPackages.length > 0) {\n    carrier.__SENTRY__.integrations = [...(carrier.__SENTRY__.integrations || []), ...mappedPackages];\n  }\n}\n\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\nexport function addExtensionMethods(): void {\n  _addTracingExtensions();\n\n  // Detect and automatically load specified integrations.\n  if (isNodeEnv()) {\n    _autoloadDatabaseIntegrations();\n  }\n\n  // If an error happens globally, we should make sure transaction status is set to error.\n  registerErrorInstrumentation();\n}\n", "export { Express } from './node/express.js';\nexport { Postgres } from './node/postgres.js';\nexport { Mysql } from './node/mysql.js';\nexport { Mongo } from './node/mongo.js';\nexport { Prisma } from './node/prisma.js';\nexport { GraphQL } from './node/graphql.js';\nexport { Apollo } from './node/apollo.js';\nexport { BrowserTracing } from '../browser/browsertracing.js';\nimport '@sentry/core';\nimport '@sentry/utils';\n//# sourceMappingURL=index.js.map\n", "import type { GenericFunction } from './types';\n\n/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nexport function _optionalChain(ops: unknown[]): unknown {\n  let lastAccessLHS: unknown = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i] as string;\n    const fn = ops[i + 1] as (intermediateValue: unknown) => unknown;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args: unknown[]) => (value as GenericFunction).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version\n// function _optionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n", "import type { Hub } from '@sentry/types';\n\n/**\n * Check if Sentry auto-instrumentation should be disabled.\n *\n * @param getCurrentHub A method to fetch the current hub\n * @returns boolean\n */\nexport function shouldDisableAutoInstrumentation(getCurrentHub: () => Hub): boolean {\n  const clientOptions = getCurrentHub().getClient()?.getOptions();\n  const instrumenter = clientOptions?.instrumenter || 'sentry';\n\n  return instrumenter !== 'sentry';\n}\n", "/* eslint-disable max-lines */\nimport type { Hub, Integration, PolymorphicRequest, Transaction } from '@sentry/types';\nimport { extractPathForTransaction, getNumberOfUrlSegments, isRegExp, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\ntype Method =\n  | 'all'\n  | 'get'\n  | 'post'\n  | 'put'\n  | 'delete'\n  | 'patch'\n  | 'options'\n  | 'head'\n  | 'checkout'\n  | 'copy'\n  | 'lock'\n  | 'merge'\n  | 'mkactivity'\n  | 'mkcol'\n  | 'move'\n  | 'm-search'\n  | 'notify'\n  | 'purge'\n  | 'report'\n  | 'search'\n  | 'subscribe'\n  | 'trace'\n  | 'unlock'\n  | 'unsubscribe'\n  | 'use';\n\ntype Router = {\n  [method in Method]: (...args: any) => any; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\n/* Extend the PolymorphicRequest type with a patched parameter to build a reconstructed route */\ntype PatchedRequest = PolymorphicRequest & { _reconstructedRoute?: string; _hasParameters?: boolean };\n\n/* Types used for patching the express router prototype */\ntype ExpressRouter = Router & {\n  _router?: ExpressRouter;\n  stack?: Layer[];\n  lazyrouter?: () => void;\n  settings?: unknown;\n  process_params: (\n    layer: Layer,\n    called: unknown,\n    req: PatchedRequest,\n    res: ExpressResponse,\n    done: () => void,\n  ) => unknown;\n};\n\ntype Layer = {\n  match: (path: string) => boolean;\n  handle_request: (req: PatchedRequest, res: ExpressResponse, next: () => void) => void;\n  route?: { path: RouteType | RouteType[] };\n  path?: string;\n};\n\ntype RouteType = string | RegExp;\n\ninterface ExpressResponse {\n  once(name: string, callback: () => void): void;\n}\n\n/**\n * Internal helper for `__sentry_transaction`\n * @hidden\n */\ninterface SentryTracingResponse {\n  __sentry_transaction?: Transaction;\n}\n\n/**\n * Express integration\n *\n * Provides an request and error handler for Express framework as well as tracing capabilities\n */\nexport class Express implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Express';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Express.id;\n\n  /**\n   * Express App instance\n   */\n  private readonly _router?: Router;\n  private readonly _methods?: Method[];\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { app?: Router; router?: Router; methods?: Method[] } = {}) {\n    this._router = options.router || options.app;\n    this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: unknown, getCurrentHub: () => Hub): void {\n    if (!this._router) {\n      __DEBUG_BUILD__ && logger.error('ExpressIntegration is missing an Express instance');\n      return;\n    }\n\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Express Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    instrumentMiddlewares(this._router, this._methods);\n    instrumentRouter(this._router as ExpressRouter);\n  }\n}\n\n/**\n * Wraps original middleware function in a tracing call, which stores the info about the call as a span,\n * and finishes it once the middleware is done invoking.\n *\n * Express middlewares have 3 various forms, thus we have to take care of all of them:\n * // sync\n * app.use(function (req, res) { ... })\n * // async\n * app.use(function (req, res, next) { ... })\n * // error handler\n * app.use(function (err, req, res, next) { ... })\n *\n * They all internally delegate to the `router[method]` of the given application instance.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nfunction wrap(fn: Function, method: Method): (...args: any[]) => void {\n  const arity = fn.length;\n\n  switch (arity) {\n    case 2: {\n      return function (this: NodeJS.Global, req: unknown, res: ExpressResponse & SentryTracingResponse): void {\n        const transaction = res.__sentry_transaction;\n        if (transaction) {\n          const span = transaction.startChild({\n            description: fn.name,\n            op: `middleware.express.${method}`,\n          });\n          res.once('finish', () => {\n            span.finish();\n          });\n        }\n        return fn.call(this, req, res);\n      };\n    }\n    case 3: {\n      return function (\n        this: NodeJS.Global,\n        req: unknown,\n        res: ExpressResponse & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `middleware.express.${method}`,\n        });\n        fn.call(this, req, res, function (this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    case 4: {\n      return function (\n        this: NodeJS.Global,\n        err: Error,\n        req: Request,\n        res: Response & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `middleware.express.${method}`,\n        });\n        fn.call(this, err, req, res, function (this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    default: {\n      throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);\n    }\n  }\n}\n\n/**\n * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`\n * and wraps every function, as well as array of functions with a call to our `wrap` method.\n * We have to take care of the arrays as well as iterate over all of the arguments,\n * as `app.use` can accept middlewares in few various forms.\n *\n * app.use([<path>], <fn>)\n * app.use([<path>], <fn>, ...<fn>)\n * app.use([<path>], ...<fn>[])\n */\nfunction wrapMiddlewareArgs(args: unknown[], method: Method): unknown[] {\n  return args.map((arg: unknown) => {\n    if (typeof arg === 'function') {\n      return wrap(arg, method);\n    }\n\n    if (Array.isArray(arg)) {\n      return arg.map((a: unknown) => {\n        if (typeof a === 'function') {\n          return wrap(a, method);\n        }\n        return a;\n      });\n    }\n\n    return arg;\n  });\n}\n\n/**\n * Patches original router to utilize our tracing functionality\n */\nfunction patchMiddleware(router: Router, method: Method): Router {\n  const originalCallback = router[method];\n\n  router[method] = function (...args: unknown[]): void {\n    return originalCallback.call(this, ...wrapMiddlewareArgs(args, method));\n  };\n\n  return router;\n}\n\n/**\n * Patches original router methods\n */\nfunction instrumentMiddlewares(router: Router, methods: Method[] = []): void {\n  methods.forEach((method: Method) => patchMiddleware(router, method));\n}\n\n/**\n * Patches the prototype of Express.Router to accumulate the resolved route\n * if a layer instance's `match` function was called and it returned a successful match.\n *\n * @see https://github.com/expressjs/express/blob/master/lib/router/index.js\n *\n * @param appOrRouter the router instance which can either be an app (i.e. top-level) or a (nested) router.\n */\nfunction instrumentRouter(appOrRouter: ExpressRouter): void {\n  // This is how we can distinguish between app and routers\n  const isApp = 'settings' in appOrRouter;\n\n  // In case the app's top-level router hasn't been initialized yet, we have to do it now\n  if (isApp && appOrRouter._router === undefined && appOrRouter.lazyrouter) {\n    appOrRouter.lazyrouter();\n  }\n\n  const router = isApp ? appOrRouter._router : appOrRouter;\n\n  if (!router) {\n    /*\n    If we end up here, this means likely that this integration is used with Express 3 or Express 5.\n    For now, we don't support these versions (3 is very old and 5 is still in beta). To support Express 5,\n    we'd need to make more changes to the routing instrumentation because the router is no longer part of\n    the Express core package but maintained in its own package. The new router has different function\n    signatures and works slightly differently, demanding more changes than just taking the router from\n    `app.router` instead of `app._router`.\n    @see https://github.com/pillarjs/router\n\n    TODO: Proper Express 5 support\n    */\n    __DEBUG_BUILD__ && logger.debug('Cannot instrument router for URL Parameterization (did not find a valid router).');\n    __DEBUG_BUILD__ && logger.debug('Routing instrumentation is currently only supported in Express 4.');\n    return;\n  }\n\n  const routerProto = Object.getPrototypeOf(router) as ExpressRouter;\n\n  const originalProcessParams = routerProto.process_params;\n  routerProto.process_params = function process_params(\n    layer: Layer,\n    called: unknown,\n    req: PatchedRequest,\n    res: ExpressResponse & SentryTracingResponse,\n    done: () => unknown,\n  ) {\n    // Base case: We're in the first part of the URL (thus we start with the root '/')\n    if (!req._reconstructedRoute) {\n      req._reconstructedRoute = '';\n    }\n\n    // If the layer's partial route has params, is a regex or an array, the route is stored in layer.route.\n    const { layerRoutePath, isRegex, isArray, numExtraSegments }: LayerRoutePathInfo = getLayerRoutePathInfo(layer);\n\n    if (layerRoutePath || isRegex || isArray) {\n      req._hasParameters = true;\n    }\n\n    // Otherwise, the hardcoded path (i.e. a partial route without params) is stored in layer.path\n    const partialRoute = layerRoutePath || layer.path || '';\n\n    // Normalize the partial route so that it doesn't contain leading or trailing slashes\n    // and exclude empty or '*' wildcard routes.\n    // The exclusion of '*' routes is our best effort to not \"pollute\" the transaction name\n    // with interim handlers (e.g. ones that check authentication or do other middleware stuff).\n    // We want to end up with the parameterized URL of the incoming request without any extraneous path segments.\n    const finalPartialRoute = partialRoute\n      .split('/')\n      .filter(segment => segment.length > 0 && (isRegex || isArray || !segment.includes('*')))\n      .join('/');\n\n    // If we found a valid partial URL, we append it to the reconstructed route\n    if (finalPartialRoute && finalPartialRoute.length > 0) {\n      // If the partial route is from a regex route, we append a '/' to close the regex\n      req._reconstructedRoute += `/${finalPartialRoute}${isRegex ? '/' : ''}`;\n    }\n\n    // Now we check if we are in the \"last\" part of the route. We determine this by comparing the\n    // number of URL segments from the original URL to that of our reconstructed parameterized URL.\n    // If we've reached our final destination, we update the transaction name.\n    const urlLength = getNumberOfUrlSegments(req.originalUrl || '') + numExtraSegments;\n    const routeLength = getNumberOfUrlSegments(req._reconstructedRoute);\n\n    if (urlLength === routeLength) {\n      if (!req._hasParameters) {\n        if (req._reconstructedRoute !== req.originalUrl) {\n          req._reconstructedRoute = req.originalUrl;\n        }\n      }\n\n      const transaction = res.__sentry_transaction;\n      if (transaction && transaction.metadata.source !== 'custom') {\n        // If the request URL is '/' or empty, the reconstructed route will be empty.\n        // Therefore, we fall back to setting the final route to '/' in this case.\n        const finalRoute = req._reconstructedRoute || '/';\n\n        transaction.setName(...extractPathForTransaction(req, { path: true, method: true, customRoute: finalRoute }));\n      }\n    }\n\n    return originalProcessParams.call(this, layer, called, req, res, done);\n  };\n}\n\ntype LayerRoutePathInfo = {\n  layerRoutePath?: string;\n  isRegex: boolean;\n  isArray: boolean;\n  numExtraSegments: number;\n};\n\n/**\n * Extracts and stringifies the layer's route which can either be a string with parameters (`users/:id`),\n * a RegEx (`/test/`) or an array of strings and regexes (`['/path1', /\\/path[2-5]/, /path/:id]`). Additionally\n * returns extra information about the route, such as if the route is defined as regex or as an array.\n *\n * @param layer the layer to extract the stringified route from\n *\n * @returns an object containing the stringified route, a flag determining if the route was a regex\n *          and the number of extra segments to the matched path that are additionally in the route,\n *          if the route was an array (defaults to 0).\n */\nfunction getLayerRoutePathInfo(layer: Layer): LayerRoutePathInfo {\n  const lrp = layer.route?.path;\n\n  const isRegex = isRegExp(lrp);\n  const isArray = Array.isArray(lrp);\n\n  if (!lrp) {\n    return { isRegex, isArray, numExtraSegments: 0 };\n  }\n\n  const numExtraSegments = isArray\n    ? Math.max(getNumberOfArrayUrlSegments(lrp as RouteType[]) - getNumberOfUrlSegments(layer.path || ''), 0)\n    : 0;\n\n  const layerRoutePath = getLayerRoutePathString(isArray, lrp);\n\n  return { layerRoutePath, isRegex, isArray, numExtraSegments };\n}\n\n/**\n * Returns the number of URL segments in an array of routes\n *\n * Example: ['/api/test', /\\/api\\/post[0-9]/, '/users/:id/details`] -> 7\n */\nfunction getNumberOfArrayUrlSegments(routesArray: RouteType[]): number {\n  return routesArray.reduce((accNumSegments: number, currentRoute: RouteType) => {\n    // array members can be a RegEx -> convert them toString\n    return accNumSegments + getNumberOfUrlSegments(currentRoute.toString());\n  }, 0);\n}\n\n/**\n * Extracts and returns the stringified version of the layers route path\n * Handles route arrays (by joining the paths together) as well as RegExp and normal\n * string values (in the latter case the toString conversion is technically unnecessary but\n * it doesn't hurt us either).\n */\nfunction getLayerRoutePathString(isArray: boolean, lrp?: RouteType | RouteType[]): string | undefined {\n  if (isArray) {\n    return (lrp as RouteType[]).map(r => r.toString()).join(',');\n  }\n  return lrp && lrp.toString();\n}\n", "import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\ninterface PgClient {\n  prototype: {\n    query: () => void | Promise<unknown>;\n  };\n}\n\ninterface PgOptions {\n  usePgNative?: boolean;\n}\n\n/** Tracing integration for node-postgres package */\nexport class Postgres implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Postgres';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Postgres.id;\n\n  private _usePgNative: boolean;\n\n  public constructor(options: PgOptions = {}) {\n    this._usePgNative = !!options.usePgNative;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Postgres Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const pkg = loadModule<{ Client: PgClient; native: { Client: PgClient } }>('pg');\n\n    if (!pkg) {\n      __DEBUG_BUILD__ && logger.error('Postgres Integration was unable to require `pg` package.');\n      return;\n    }\n\n    if (this._usePgNative && !pkg.native?.Client) {\n      __DEBUG_BUILD__ && logger.error(\"Postgres Integration was unable to access 'pg-native' bindings.\");\n      return;\n    }\n\n    const { Client } = this._usePgNative ? pkg.native : pkg;\n\n    /**\n     * function (query, callback) => void\n     * function (query, params, callback) => void\n     * function (query) => Promise\n     * function (query, params) => Promise\n     * function (pg.Cursor) => pg.Cursor\n     */\n    fill(Client.prototype, 'query', function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, config: unknown, values: unknown, callback: unknown) {\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n        const span = parentSpan?.startChild({\n          description: typeof config === 'string' ? config : (config as { text: string }).text,\n          op: 'db',\n        });\n\n        if (typeof callback === 'function') {\n          return orig.call(this, config, values, function (err: Error, result: unknown) {\n            span?.finish();\n            callback(err, result);\n          });\n        }\n\n        if (typeof values === 'function') {\n          return orig.call(this, config, function (err: Error, result: unknown) {\n            span?.finish();\n            values(err, result);\n          });\n        }\n\n        const rv = typeof values !== 'undefined' ? orig.call(this, config, values) : orig.call(this, config);\n\n        if (isThenable(rv)) {\n          return rv.then((res: unknown) => {\n            span?.finish();\n            return res;\n          });\n        }\n\n        span?.finish();\n        return rv;\n      };\n    });\n  }\n}\n", "import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration } from '@sentry/types';\nimport { fill, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\ninterface MysqlConnection {\n  createQuery: () => void;\n}\n\n/** Tracing integration for node-mysql package */\nexport class Mysql implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mysql';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Mysql.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Mysql Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const pkg = loadModule<MysqlConnection>('mysql/lib/Connection.js');\n\n    if (!pkg) {\n      __DEBUG_BUILD__ && logger.error('Mysql Integration was unable to require `mysql` package.');\n      return;\n    }\n\n    // The original function will have one of these signatures:\n    //    function (callback) => void\n    //    function (options, callback) => void\n    //    function (options, values, callback) => void\n    fill(pkg, 'createQuery', function (orig: () => void) {\n      return function (this: unknown, options: unknown, values: unknown, callback: unknown) {\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n        const span = parentSpan?.startChild({\n          description: typeof options === 'string' ? options : (options as { sql: string }).sql,\n          op: 'db',\n        });\n\n        if (typeof callback === 'function') {\n          return orig.call(this, options, values, function (err: Error, result: unknown, fields: unknown) {\n            span?.finish();\n            callback(err, result, fields);\n          });\n        }\n\n        if (typeof values === 'function') {\n          return orig.call(this, options, function (err: Error, result: unknown, fields: unknown) {\n            span?.finish();\n            values(err, result, fields);\n          });\n        }\n\n        return orig.call(this, options, values, callback);\n      };\n    });\n  }\n}\n", "import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration, SpanContext } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\ntype Operation = typeof OPERATIONS[number];\nconst OPERATIONS = [\n  'aggregate', // aggregate(pipeline, options, callback)\n  'bulkWrite', // bulkWrite(operations, options, callback)\n  'countDocuments', // countDocuments(query, options, callback)\n  'createIndex', // createIndex(fieldOrSpec, options, callback)\n  'createIndexes', // createIndexes(indexSpecs, options, callback)\n  'deleteMany', // deleteMany(filter, options, callback)\n  'deleteOne', // deleteOne(filter, options, callback)\n  'distinct', // distinct(key, query, options, callback)\n  'drop', // drop(options, callback)\n  'dropIndex', // dropIndex(indexName, options, callback)\n  'dropIndexes', // dropIndexes(options, callback)\n  'estimatedDocumentCount', // estimatedDocumentCount(options, callback)\n  'find', // find(query, options, callback)\n  'findOne', // findOne(query, options, callback)\n  'findOneAndDelete', // findOneAndDelete(filter, options, callback)\n  'findOneAndReplace', // findOneAndReplace(filter, replacement, options, callback)\n  'findOneAndUpdate', // findOneAndUpdate(filter, update, options, callback)\n  'indexes', // indexes(options, callback)\n  'indexExists', // indexExists(indexes, options, callback)\n  'indexInformation', // indexInformation(options, callback)\n  'initializeOrderedBulkOp', // initializeOrderedBulkOp(options, callback)\n  'insertMany', // insertMany(docs, options, callback)\n  'insertOne', // insertOne(doc, options, callback)\n  'isCapped', // isCapped(options, callback)\n  'mapReduce', // mapReduce(map, reduce, options, callback)\n  'options', // options(options, callback)\n  'parallelCollectionScan', // parallelCollectionScan(options, callback)\n  'rename', // rename(newName, options, callback)\n  'replaceOne', // replaceOne(filter, doc, options, callback)\n  'stats', // stats(options, callback)\n  'updateMany', // updateMany(filter, update, options, callback)\n  'updateOne', // updateOne(filter, update, options, callback)\n] as const;\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES: {\n  [op in Operation]?: string[];\n} = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update'],\n};\n\ninterface MongoCollection {\n  collectionName: string;\n  dbName: string;\n  namespace: string;\n  prototype: {\n    [operation in Operation]: (...args: unknown[]) => unknown;\n  };\n}\n\ninterface MongoOptions {\n  operations?: Operation[];\n  describeOperations?: boolean | Operation[];\n  useMongoose?: boolean;\n}\n\ninterface MongoCursor {\n  once(event: 'close', listener: () => void): void;\n}\n\nfunction isCursor(maybeCursor: MongoCursor): maybeCursor is MongoCursor {\n  return maybeCursor && typeof maybeCursor === 'object' && maybeCursor.once && typeof maybeCursor.once === 'function';\n}\n\n/** Tracing integration for mongo package */\nexport class Mongo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mongo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Mongo.id;\n\n  private _operations: Operation[];\n  private _describeOperations?: boolean | Operation[];\n  private _useMongoose: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: MongoOptions = {}) {\n    this._operations = Array.isArray(options.operations) ? options.operations : (OPERATIONS as unknown as Operation[]);\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Mongo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    const pkg = loadModule<{ Collection: MongoCollection }>(moduleName);\n\n    if (!pkg) {\n      __DEBUG_BUILD__ && logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  private _instrumentOperations(collection: MongoCollection, operations: Operation[], getCurrentHub: () => Hub): void {\n    operations.forEach((operation: Operation) => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  private _patchOperation(collection: MongoCollection, operation: Operation, getCurrentHub: () => Hub): void {\n    if (!(operation in collection.prototype)) return;\n\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n\n    fill(collection.prototype, operation, function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, ...args: unknown[]) {\n        const lastArg = args[args.length - 1];\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {\n          const span = parentSpan?.startChild(getSpanContext(this, operation, args));\n          const maybePromiseOrCursor = orig.call(this, ...args);\n\n          if (isThenable(maybePromiseOrCursor)) {\n            return maybePromiseOrCursor.then((res: unknown) => {\n              span?.finish();\n              return res;\n            });\n          }\n          // If the operation returns a Cursor\n          // we need to attach a listener to it to finish the span when the cursor is closed.\n          else if (isCursor(maybePromiseOrCursor)) {\n            const cursor = maybePromiseOrCursor as MongoCursor;\n\n            try {\n              cursor.once('close', () => {\n                span?.finish();\n              });\n            } catch (e) {\n              // If the cursor is already closed, `once` will throw an error. In that case, we can\n              // finish the span immediately.\n              span?.finish();\n            }\n\n            return cursor;\n          } else {\n            span?.finish();\n            return maybePromiseOrCursor;\n          }\n        }\n\n        const span = parentSpan?.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n\n        return orig.call(this, ...args.slice(0, -1), function (err: Error, result: unknown) {\n          span?.finish();\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  private _getSpanContextFromOperationArguments(\n    collection: MongoCollection,\n    operation: Operation,\n    args: unknown[],\n  ): SpanContext {\n    const data: { [key: string]: string } = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace,\n    };\n    const spanContext: SpanContext = {\n      op: 'db',\n      description: operation,\n      data,\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations)\n      ? this._describeOperations.includes(operation)\n      : this._describeOperations;\n\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args as { name?: string }[];\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n\n    return spanContext;\n  }\n}\n", "import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration } from '@sentry/types';\nimport { isThenable, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\ntype PrismaAction =\n  | 'findUnique'\n  | 'findMany'\n  | 'findFirst'\n  | 'create'\n  | 'createMany'\n  | 'update'\n  | 'updateMany'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw';\n\ninterface PrismaMiddlewareParams {\n  model?: unknown;\n  action: PrismaAction;\n  args: unknown;\n  dataPath: string[];\n  runInTransaction: boolean;\n}\n\ntype PrismaMiddleware<T = unknown> = (\n  params: PrismaMiddlewareParams,\n  next: (params: PrismaMiddlewareParams) => Promise<T>,\n) => Promise<T>;\n\ninterface PrismaClient {\n  $use: (cb: PrismaMiddleware) => void;\n}\n\nfunction isValidPrismaClient(possibleClient: unknown): possibleClient is PrismaClient {\n  return possibleClient && !!(possibleClient as PrismaClient)['$use'];\n}\n\n/** Tracing integration for @prisma/client package */\nexport class Prisma implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Prisma';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Prisma.id;\n\n  /**\n   * Prisma ORM Client Instance\n   */\n  private readonly _client?: PrismaClient;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { client?: unknown } = {}) {\n    if (isValidPrismaClient(options.client)) {\n      this._client = options.client;\n    } else {\n      __DEBUG_BUILD__ &&\n        logger.warn(\n          `Unsupported Prisma client provided to PrismaIntegration. Provided client: ${JSON.stringify(options.client)}`,\n        );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (!this._client) {\n      __DEBUG_BUILD__ && logger.error('PrismaIntegration is missing a Prisma Client Instance');\n      return;\n    }\n\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Prisma Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    this._client.$use((params, next: (params: PrismaMiddlewareParams) => Promise<unknown>) => {\n      const scope = getCurrentHub().getScope();\n      const parentSpan = scope?.getSpan();\n\n      const action = params.action;\n      const model = params.model;\n\n      const span = parentSpan?.startChild({\n        description: model ? `${model} ${action}` : action,\n        op: 'db.sql.prisma',\n      });\n\n      const rv = next(params);\n\n      if (isThenable(rv)) {\n        return rv.then((res: unknown) => {\n          span?.finish();\n          return res;\n        });\n      }\n\n      span?.finish();\n      return rv;\n    });\n  }\n}\n", "import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\n/** Tracing integration for graphql package */\nexport class GraphQL implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'GraphQL';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = GraphQL.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('GraphQL Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const pkg = loadModule<{\n      [method: string]: (...args: unknown[]) => unknown;\n    }>('graphql/execution/execute.js');\n\n    if (!pkg) {\n      __DEBUG_BUILD__ && logger.error('GraphQL Integration was unable to require graphql/execution package.');\n      return;\n    }\n\n    fill(pkg, 'execute', function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, ...args: unknown[]) {\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n\n        const span = parentSpan?.startChild({\n          description: 'execute',\n          op: 'graphql.execute',\n        });\n\n        scope?.setSpan(span);\n\n        const rv = orig.call(this, ...args);\n\n        if (isThenable(rv)) {\n          return rv.then((res: unknown) => {\n            span?.finish();\n            scope?.setSpan(parentSpan);\n\n            return res;\n          });\n        }\n\n        span?.finish();\n        scope?.setSpan(parentSpan);\n        return rv;\n      };\n    });\n  }\n}\n", "import type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration } from '@sentry/types';\nimport { arrayify, fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\ninterface ApolloOptions {\n  useNestjs?: boolean;\n}\n\ntype ApolloResolverGroup = {\n  [key: string]: () => unknown;\n};\n\ntype ApolloModelResolvers = {\n  [key: string]: ApolloResolverGroup;\n};\n\n/** Tracing integration for Apollo */\nexport class Apollo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Apollo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Apollo.id;\n\n  private readonly _useNest: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    options: ApolloOptions = {\n      useNestjs: false,\n    },\n  ) {\n    this._useNest = !!options.useNestjs;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Apollo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    if (this._useNest) {\n      const pkg = loadModule<{\n        GraphQLFactory: {\n          prototype: {\n            create: (resolvers: ApolloModelResolvers[]) => unknown;\n          };\n        };\n      }>('@nestjs/graphql');\n\n      if (!pkg) {\n        __DEBUG_BUILD__ && logger.error('Apollo-NestJS Integration was unable to require @nestjs/graphql package.');\n        return;\n      }\n\n      /**\n       * Iterate over resolvers of NestJS ResolversExplorerService before schemas are constructed.\n       */\n      fill(\n        pkg.GraphQLFactory.prototype,\n        'mergeWithSchema',\n        function (orig: (this: unknown, ...args: unknown[]) => unknown) {\n          return function (\n            this: { resolversExplorerService: { explore: () => ApolloModelResolvers[] } },\n            ...args: unknown[]\n          ) {\n            fill(this.resolversExplorerService, 'explore', function (orig: () => ApolloModelResolvers[]) {\n              return function (this: unknown) {\n                const resolvers = arrayify(orig.call(this));\n\n                const instrumentedResolvers = instrumentResolvers(resolvers, getCurrentHub);\n\n                return instrumentedResolvers;\n              };\n            });\n\n            return orig.call(this, ...args);\n          };\n        },\n      );\n    } else {\n      const pkg = loadModule<{\n        ApolloServerBase: {\n          prototype: {\n            constructSchema: (config: unknown) => unknown;\n          };\n        };\n      }>('apollo-server-core');\n\n      if (!pkg) {\n        __DEBUG_BUILD__ && logger.error('Apollo Integration was unable to require apollo-server-core package.');\n        return;\n      }\n\n      /**\n       * Iterate over resolvers of the ApolloServer instance before schemas are constructed.\n       */\n      fill(pkg.ApolloServerBase.prototype, 'constructSchema', function (orig: (config: unknown) => unknown) {\n        return function (this: {\n          config: { resolvers?: ApolloModelResolvers[]; schema?: unknown; modules?: unknown };\n        }) {\n          if (!this.config.resolvers) {\n            if (__DEBUG_BUILD__) {\n              if (this.config.schema) {\n                logger.warn(\n                  'Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.' +\n                    'If you are using NestJS with Apollo, please use `Sentry.Integrations.Apollo({ useNestjs: true })` instead.',\n                );\n                logger.warn();\n              } else if (this.config.modules) {\n                logger.warn(\n                  'Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.',\n                );\n              }\n\n              logger.error('Skipping tracing as no resolvers found on the `ApolloServer` instance.');\n            }\n\n            return orig.call(this);\n          }\n\n          const resolvers = arrayify(this.config.resolvers);\n\n          this.config.resolvers = instrumentResolvers(resolvers, getCurrentHub);\n\n          return orig.call(this);\n        };\n      });\n    }\n  }\n}\n\nfunction instrumentResolvers(resolvers: ApolloModelResolvers[], getCurrentHub: () => Hub): ApolloModelResolvers[] {\n  return resolvers.map(model => {\n    Object.keys(model).forEach(resolverGroupName => {\n      Object.keys(model[resolverGroupName]).forEach(resolverName => {\n        if (typeof model[resolverGroupName][resolverName] !== 'function') {\n          return;\n        }\n\n        wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);\n      });\n    });\n\n    return model;\n  });\n}\n\n/**\n * Wrap a single resolver which can be a parent of other resolvers and/or db operations.\n */\nfunction wrapResolver(\n  model: ApolloModelResolvers,\n  resolverGroupName: string,\n  resolverName: string,\n  getCurrentHub: () => Hub,\n): void {\n  fill(model[resolverGroupName], resolverName, function (orig: () => unknown | Promise<unknown>) {\n    return function (this: unknown, ...args: unknown[]) {\n      const scope = getCurrentHub().getScope();\n      const parentSpan = scope?.getSpan();\n      const span = parentSpan?.startChild({\n        description: `${resolverGroupName}.${resolverName}`,\n        op: 'graphql.resolve',\n      });\n\n      const rv = orig.call(this, ...args);\n\n      if (isThenable(rv)) {\n        return rv.then((res: unknown) => {\n          span?.finish();\n          return res;\n        });\n      }\n\n      span?.finish();\n\n      return rv;\n    };\n  });\n}\n", "import { GLOBAL_OBJ } from '@sentry/utils';\n\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n", "import { logger } from '@sentry/utils';\n\nimport type { IdleTransaction } from '../idletransaction';\nimport type { SpanStatusType } from '../span';\nimport { getActiveTransaction } from '../utils';\nimport { WINDOW } from './types';\n\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nexport function registerBackgroundTabDetection(): void {\n  if (WINDOW && WINDOW.document) {\n    WINDOW.document.addEventListener('visibilitychange', () => {\n      const activeTransaction = getActiveTransaction() as IdleTransaction;\n      if (WINDOW.document.hidden && activeTransaction) {\n        const statusType: SpanStatusType = 'cancelled';\n\n        __DEBUG_BUILD__ &&\n          logger.log(\n            `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`,\n          );\n        // We should not set status if it is already set, this prevent important statuses like\n        // error or data loss from being overwritten on transaction.\n        if (!activeTransaction.status) {\n          activeTransaction.setStatus(statusType);\n        }\n        activeTransaction.setTag('visibilitychange', 'document.hidden');\n        activeTransaction.finish();\n      }\n    });\n  } else {\n    __DEBUG_BUILD__ &&\n      logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');\n  }\n}\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Metric, ReportCallback } from '../types';\n\nexport const bindReporter = (\n  callback: ReportCallback,\n  metric: Metric,\n  reportAllChanges?: boolean,\n): ((forceReport?: boolean) => void) => {\n  let prevValue: number;\n  let delta: number;\n  return (forceReport?: boolean) => {\n    if (metric.value >= 0) {\n      if (forceReport || reportAllChanges) {\n        delta = metric.value - (prevValue || 0);\n\n        // Report the metric if there's a non-zero delta or if no previous\n        // value exists (which can happen in the case of the document becoming\n        // hidden when the metric value is 0).\n        // See: https://github.com/GoogleChrome/web-vitals/issues/14\n        if (delta || prevValue === undefined) {\n          prevValue = metric.value;\n          metric.delta = delta;\n          callback(metric);\n        }\n      }\n    }\n  };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nexport const generateUniqueID = (): string => {\n  return `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WINDOW } from '../../types';\nimport type { NavigationTimingPolyfillEntry } from '../types';\n\nconst getNavigationEntryFromPerformanceTiming = (): NavigationTimingPolyfillEntry => {\n  // eslint-disable-next-line deprecation/deprecation\n  const timing = WINDOW.performance.timing;\n  // eslint-disable-next-line deprecation/deprecation\n  const type = WINDOW.performance.navigation.type;\n\n  const navigationEntry: { [key: string]: number | string } = {\n    entryType: 'navigation',\n    startTime: 0,\n    type: type == 2 ? 'back_forward' : type === 1 ? 'reload' : 'navigate',\n  };\n\n  for (const key in timing) {\n    if (key !== 'navigationStart' && key !== 'toJSON') {\n      navigationEntry[key] = Math.max((timing[key as keyof PerformanceTiming] as number) - timing.navigationStart, 0);\n    }\n  }\n  return navigationEntry as unknown as NavigationTimingPolyfillEntry;\n};\n\nexport const getNavigationEntry = (): PerformanceNavigationTiming | NavigationTimingPolyfillEntry | undefined => {\n  if (WINDOW.__WEB_VITALS_POLYFILL__) {\n    return (\n      WINDOW.performance &&\n      ((performance.getEntriesByType && performance.getEntriesByType('navigation')[0]) ||\n        getNavigationEntryFromPerformanceTiming())\n    );\n  } else {\n    return WINDOW.performance && performance.getEntriesByType && performance.getEntriesByType('navigation')[0];\n  }\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getNavigationEntry } from './getNavigationEntry';\n\nexport const getActivationStart = (): number => {\n  const navEntry = getNavigationEntry();\n  return (navEntry && navEntry.activationStart) || 0;\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WINDOW } from '../../types';\nimport type { Metric } from '../types';\nimport { generateUniqueID } from './generateUniqueID';\nimport { getActivationStart } from './getActivationStart';\nimport { getNavigationEntry } from './getNavigationEntry';\n\nexport const initMetric = (name: Metric['name'], value?: number): Metric => {\n  const navEntry = getNavigationEntry();\n  let navigationType: Metric['navigationType'] = 'navigate';\n\n  if (navEntry) {\n    if (WINDOW.document.prerendering || getActivationStart() > 0) {\n      navigationType = 'prerender';\n    } else {\n      navigationType = navEntry.type.replace(/_/g, '-') as Metric['navigationType'];\n    }\n  }\n\n  return {\n    name,\n    value: typeof value === 'undefined' ? -1 : value,\n    rating: 'good', // Will be updated if the value changes.\n    delta: 0,\n    entries: [],\n    id: generateUniqueID(),\n    navigationType,\n  };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { FirstInputPolyfillEntry, NavigationTimingPolyfillEntry, PerformancePaintTiming } from '../types';\n\nexport interface PerformanceEntryHandler {\n  (entry: PerformanceEntry): void;\n}\n\ninterface PerformanceEntryMap {\n  event: PerformanceEventTiming[];\n  paint: PerformancePaintTiming[];\n  'layout-shift': LayoutShift[];\n  'largest-contentful-paint': LargestContentfulPaint[];\n  'first-input': PerformanceEventTiming[] | FirstInputPolyfillEntry[];\n  navigation: PerformanceNavigationTiming[] | NavigationTimingPolyfillEntry[];\n  resource: PerformanceResourceTiming[];\n  longtask: PerformanceEntry[];\n}\n\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nexport const observe = <K extends keyof PerformanceEntryMap>(\n  type: K,\n  callback: (entries: PerformanceEntryMap[K]) => void,\n  opts?: PerformanceObserverInit,\n): PerformanceObserver | undefined => {\n  try {\n    if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n      const po = new PerformanceObserver(list => {\n        callback(list.getEntries() as PerformanceEntryMap[K]);\n      });\n      po.observe(\n        Object.assign(\n          {\n            type,\n            buffered: true,\n          },\n          opts || {},\n        ) as PerformanceObserverInit,\n      );\n      return po;\n    }\n  } catch (e) {\n    // Do nothing.\n  }\n  return;\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WINDOW } from '../../types';\n\nexport interface OnHiddenCallback {\n  (event: Event): void;\n}\n\nexport const onHidden = (cb: OnHiddenCallback, once?: boolean): void => {\n  const onHiddenOrPageHide = (event: Event): void => {\n    if (event.type === 'pagehide' || WINDOW.document.visibilityState === 'hidden') {\n      cb(event);\n      if (once) {\n        removeEventListener('visibilitychange', onHiddenOrPageHide, true);\n        removeEventListener('pagehide', onHiddenOrPageHide, true);\n      }\n    }\n  };\n  addEventListener('visibilitychange', onHiddenOrPageHide, true);\n  // Some browsers have buggy implementations of visibilitychange,\n  // so we use pagehide in addition, just to be safe.\n  addEventListener('pagehide', onHiddenOrPageHide, true);\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bindReporter } from './lib/bindReporter';\nimport { initMetric } from './lib/initMetric';\nimport { observe } from './lib/observe';\nimport { onHidden } from './lib/onHidden';\nimport type { CLSMetric, ReportCallback } from './types';\n\n/**\n * Calculates the [CLS](https://web.dev/cls/) value for the current page and\n * calls the `callback` function once the value is ready to be reported, along\n * with all `layout-shift` performance entries that were used in the metric\n * value calculation. The reported value is a `double` (corresponding to a\n * [layout shift score](https://web.dev/cls/#layout-shift-score)).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** CLS should be continually monitored for changes throughout\n * the entire lifespan of a page—including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onCLS = (onReport: ReportCallback): void => {\n  const metric = initMetric('CLS', 0);\n  let report: ReturnType<typeof bindReporter>;\n\n  let sessionValue = 0;\n  let sessionEntries: PerformanceEntry[] = [];\n\n  // const handleEntries = (entries: Metric['entries']) => {\n  const handleEntries = (entries: LayoutShift[]): void => {\n    entries.forEach(entry => {\n      // Only count layout shifts without recent user input.\n      if (!entry.hadRecentInput) {\n        const firstSessionEntry = sessionEntries[0];\n        const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n\n        // If the entry occurred less than 1 second after the previous entry and\n        // less than 5 seconds after the first entry in the session, include the\n        // entry in the current session. Otherwise, start a new session.\n        if (\n          sessionValue &&\n          sessionEntries.length !== 0 &&\n          entry.startTime - lastSessionEntry.startTime < 1000 &&\n          entry.startTime - firstSessionEntry.startTime < 5000\n        ) {\n          sessionValue += entry.value;\n          sessionEntries.push(entry);\n        } else {\n          sessionValue = entry.value;\n          sessionEntries = [entry];\n        }\n\n        // If the current session value is larger than the current CLS value,\n        // update CLS and the entries contributing to it.\n        if (sessionValue > metric.value) {\n          metric.value = sessionValue;\n          metric.entries = sessionEntries;\n          if (report) {\n            report();\n          }\n        }\n      }\n    });\n  };\n\n  const po = observe('layout-shift', handleEntries);\n  if (po) {\n    report = bindReporter(onReport, metric);\n\n    onHidden(() => {\n      handleEntries(po.takeRecords() as CLSMetric['entries']);\n      report(true);\n    });\n  }\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WINDOW } from '../../types';\nimport { onHidden } from './onHidden';\n\nlet firstHiddenTime = -1;\n\nconst initHiddenTime = (): number => {\n  // If the document is hidden and not prerendering, assume it was always\n  // hidden and the page was loaded in the background.\n  return WINDOW.document.visibilityState === 'hidden' && !WINDOW.document.prerendering ? 0 : Infinity;\n};\n\nconst trackChanges = (): void => {\n  // Update the time if/when the document becomes hidden.\n  onHidden(({ timeStamp }) => {\n    firstHiddenTime = timeStamp;\n  }, true);\n};\n\nexport const getVisibilityWatcher = (): {\n  readonly firstHiddenTime: number;\n} => {\n  if (firstHiddenTime < 0) {\n    // If the document is hidden when this code runs, assume it was hidden\n    // since navigation start. This isn't a perfect heuristic, but it's the\n    // best we can do until an API is available to support querying past\n    // visibilityState.\n    firstHiddenTime = initHiddenTime();\n    trackChanges();\n  }\n  return {\n    get firstHiddenTime() {\n      return firstHiddenTime;\n    },\n  };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bindReporter } from './lib/bindReporter';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher';\nimport { initMetric } from './lib/initMetric';\nimport { observe } from './lib/observe';\nimport { onHidden } from './lib/onHidden';\nimport type { FIDMetric, PerformanceEventTiming, ReportCallback } from './types';\n\n/**\n * Calculates the [FID](https://web.dev/fid/) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `first-input` performance entry used to determine the value. The\n * reported value is a `DOMHighResTimeStamp`.\n *\n * _**Important:** since FID is only reported after the user interacts with the\n * page, it's possible that it will not be reported for some page loads._\n */\nexport const onFID = (onReport: ReportCallback): void => {\n  const visibilityWatcher = getVisibilityWatcher();\n  const metric = initMetric('FID');\n  // eslint-disable-next-line prefer-const\n  let report: ReturnType<typeof bindReporter>;\n\n  const handleEntry = (entry: PerformanceEventTiming): void => {\n    // Only report if the page wasn't hidden prior to the first input.\n    if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n      metric.value = entry.processingStart - entry.startTime;\n      metric.entries.push(entry);\n      report(true);\n    }\n  };\n\n  const handleEntries = (entries: FIDMetric['entries']): void => {\n    (entries as PerformanceEventTiming[]).forEach(handleEntry);\n  };\n\n  const po = observe('first-input', handleEntries);\n  report = bindReporter(onReport, metric);\n\n  if (po) {\n    onHidden(() => {\n      handleEntries(po.takeRecords() as FIDMetric['entries']);\n      po.disconnect();\n    }, true);\n  }\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bindReporter } from './lib/bindReporter';\nimport { getActivationStart } from './lib/getActivationStart';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher';\nimport { initMetric } from './lib/initMetric';\nimport { observe } from './lib/observe';\nimport { onHidden } from './lib/onHidden';\nimport type { LCPMetric, ReportCallback } from './types';\n\nconst reportedMetricIDs: Record<string, boolean> = {};\n\n/**\n * Calculates the [LCP](https://web.dev/lcp/) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n */\nexport const onLCP = (onReport: ReportCallback): void => {\n  const visibilityWatcher = getVisibilityWatcher();\n  const metric = initMetric('LCP');\n  let report: ReturnType<typeof bindReporter>;\n\n  const handleEntries = (entries: LCPMetric['entries']): void => {\n    const lastEntry = entries[entries.length - 1] as LargestContentfulPaint;\n    if (lastEntry) {\n      // The startTime attribute returns the value of the renderTime if it is\n      // not 0, and the value of the loadTime otherwise. The activationStart\n      // reference is used because LCP should be relative to page activation\n      // rather than navigation start if the page was prerendered.\n      const value = Math.max(lastEntry.startTime - getActivationStart(), 0);\n\n      // Only report if the page wasn't hidden prior to LCP.\n      if (value < visibilityWatcher.firstHiddenTime) {\n        metric.value = value;\n        metric.entries = [lastEntry];\n        report();\n      }\n    }\n  };\n\n  const po = observe('largest-contentful-paint', handleEntries);\n\n  if (po) {\n    report = bindReporter(onReport, metric);\n\n    const stopListening = (): void => {\n      if (!reportedMetricIDs[metric.id]) {\n        handleEntries(po.takeRecords() as LCPMetric['entries']);\n        po.disconnect();\n        reportedMetricIDs[metric.id] = true;\n        report(true);\n      }\n    };\n\n    // Stop listening after input. Note: while scrolling is an input that\n    // stop LCP observation, it's unreliable since it can be programmatically\n    // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n    ['keydown', 'click'].forEach(type => {\n      addEventListener(type, stopListening, { once: true, capture: true });\n    });\n\n    onHidden(stopListening, true);\n  }\n};\n", "import type { Span, SpanContext } from '@sentry/types';\n\nimport type { Transaction } from '../../transaction';\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nexport function isMeasurementValue(value: unknown): value is number {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n", "/* eslint-disable max-lines */\nimport type { Measurements } from '@sentry/types';\nimport { browserPerformanceTimeOrigin, htmlTreeAsString, logger } from '@sentry/utils';\n\nimport type { IdleTransaction } from '../../idletransaction';\nimport type { Transaction } from '../../transaction';\nimport { getActiveTransaction, msToSec } from '../../utils';\nimport { WINDOW } from '../types';\nimport { onCLS } from '../web-vitals/getCLS';\nimport { onFID } from '../web-vitals/getFID';\nimport { onLCP } from '../web-vitals/getLCP';\nimport { getVisibilityWatcher } from '../web-vitals/lib/getVisibilityWatcher';\nimport { observe } from '../web-vitals/lib/observe';\nimport type { NavigatorDeviceMemory, NavigatorNetworkInformation } from '../web-vitals/types';\nimport { _startChild, isMeasurementValue } from './utils';\n\nfunction getBrowserPerformanceAPI(): Performance | undefined {\n  return WINDOW && WINDOW.addEventListener && WINDOW.performance;\n}\n\nlet _performanceCursor: number = 0;\n\nlet _measurements: Measurements = {};\nlet _lcpEntry: LargestContentfulPaint | undefined;\nlet _clsEntry: LayoutShift | undefined;\n\n/**\n * Start tracking web vitals\n */\nexport function startTrackingWebVitals(): void {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin) {\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    _trackCLS();\n    _trackLCP();\n    _trackFID();\n  }\n}\n\n/**\n * Start tracking long tasks.\n */\nexport function startTrackingLongTasks(): void {\n  const entryHandler = (entries: PerformanceEntry[]): void => {\n    for (const entry of entries) {\n      const transaction = getActiveTransaction() as IdleTransaction | undefined;\n      if (!transaction) {\n        return;\n      }\n      const startTime = msToSec((browserPerformanceTimeOrigin as number) + entry.startTime);\n      const duration = msToSec(entry.duration);\n\n      transaction.startChild({\n        description: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        startTimestamp: startTime,\n        endTimestamp: startTime + duration,\n      });\n    }\n  };\n\n  observe('longtask', entryHandler);\n}\n\n/** Starts tracking the Cumulative Layout Shift on the current page. */\nfunction _trackCLS(): void {\n  // See:\n  // https://web.dev/evolving-cls/\n  // https://web.dev/cls-web-tooling/\n  onCLS(metric => {\n    const entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    __DEBUG_BUILD__ && logger.log('[Measurements] Adding CLS');\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry as LayoutShift;\n  });\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP(): void {\n  onLCP(metric => {\n    const entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    __DEBUG_BUILD__ && logger.log('[Measurements] Adding LCP');\n    _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n    _lcpEntry = entry as LargestContentfulPaint;\n  });\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID(): void {\n  onFID(metric => {\n    const entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin as number);\n    const startTime = msToSec(entry.startTime);\n    __DEBUG_BUILD__ && logger.log('[Measurements] Adding FID');\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\n/** Add performance related spans to a transaction */\nexport function addPerformanceEntries(transaction: Transaction): void {\n  const performance = getBrowserPerformanceAPI();\n  if (!performance || !WINDOW.performance.getEntries || !browserPerformanceTimeOrigin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  __DEBUG_BUILD__ && logger.log('[Tracing] Adding & adjusting spans using Performance API');\n  const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n  const performanceEntries = performance.getEntries();\n\n  let responseStartTimestamp: number | undefined;\n  let requestStartTimestamp: number | undefined;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  performanceEntries.slice(_performanceCursor).forEach((entry: Record<string, any>) => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(entry.duration);\n\n    if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(transaction, entry, timeOrigin);\n        responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n        requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n\n        // capture web vitals\n        const firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          __DEBUG_BUILD__ && logger.log('[Measurements] Adding FP');\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          __DEBUG_BUILD__ && logger.log('[Measurements] Adding FCP');\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        const resourceName = (entry.name as string).replace(WINDOW.location.origin, '');\n        _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n        break;\n      }\n      default:\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(transaction);\n\n  // Measurements are only available for pageload transactions\n  if (transaction.op === 'pageload') {\n    // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n    // start of the response in milliseconds\n    if (typeof responseStartTimestamp === 'number') {\n      __DEBUG_BUILD__ && logger.log('[Measurements] Adding TTFB');\n      _measurements['ttfb'] = {\n        value: (responseStartTimestamp - transaction.startTimestamp) * 1000,\n        unit: 'millisecond',\n      };\n\n      if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n        // Capture the time spent making the request and receiving the first byte of the response.\n        // This is the time between the start of the request and the start of the response in milliseconds.\n        _measurements['ttfb.requestTime'] = {\n          value: (responseStartTimestamp - requestStartTimestamp) * 1000,\n          unit: 'millisecond',\n        };\n      }\n    }\n\n    ['fcp', 'fp', 'lcp'].forEach(name => {\n      if (!_measurements[name] || timeOrigin >= transaction.startTimestamp) {\n        return;\n      }\n      // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n      // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n      // to be adjusted to be relative to transaction.startTimestamp.\n      const oldValue = _measurements[name].value;\n      const measurementTimestamp = timeOrigin + msToSec(oldValue);\n\n      // normalizedValue should be in milliseconds\n      const normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n      const delta = normalizedValue - oldValue;\n\n      __DEBUG_BUILD__ &&\n        logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n      _measurements[name].value = normalizedValue;\n    });\n\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      _startChild(transaction, {\n        description: 'first input delay',\n        endTimestamp: fidMark.value + msToSec(_measurements['fid'].value),\n        op: 'ui.action',\n        startTimestamp: fidMark.value,\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    if (!('fcp' in _measurements)) {\n      delete _measurements.cls;\n    }\n\n    Object.keys(_measurements).forEach(measurementName => {\n      transaction.setMeasurement(\n        measurementName,\n        _measurements[measurementName].value,\n        _measurements[measurementName].unit,\n      );\n    });\n\n    _tagMetricInfo(transaction);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/** Create measure related spans */\nexport function _addMeasureSpans(\n  transaction: Transaction,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  entry: Record<string, any>,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number {\n  const measureStartTimestamp = timeOrigin + startTime;\n  const measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name as string,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType as string,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\n/** Instrument navigation entries */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _addNavigationSpans(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');\n  _addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');\n  _addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');\n  _addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  transaction: Transaction,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  entry: Record<string, any>,\n  event: string,\n  timeOrigin: number,\n  description?: string,\n  eventEnd?: string,\n): void {\n  const end = eventEnd ? (entry[eventEnd] as number | undefined) : (entry[`${event}End`] as number | undefined);\n  const start = entry[`${event}Start`] as number | undefined;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: description || event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end),\n  });\n}\n\n/** Create request and response related spans */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _addRequest(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n}\n\nexport interface ResourceEntry extends Record<string, unknown> {\n  initiatorType?: string;\n  transferSize?: number;\n  encodedBodySize?: number;\n  decodedBodySize?: number;\n  renderBlockingStatus?: string;\n}\n\n/** Create resource-related spans */\nexport function _addResourceSpans(\n  transaction: Transaction,\n  entry: ResourceEntry,\n  resourceName: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): void {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const data: Record<string, any> = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n  if ('renderBlockingStatus' in entry) {\n    data['resource.render_blocking_status'] = entry.renderBlockingStatus;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other',\n    startTimestamp,\n    data,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(transaction: Transaction): void {\n  const navigator = WINDOW.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      transaction.setTag('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      transaction.setTag('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    transaction.setTag('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to transaction to allow debugging */\nfunction _tagMetricInfo(transaction: Transaction): void {\n  if (_lcpEntry) {\n    __DEBUG_BUILD__ && logger.log('[Measurements] Adding LCP Data');\n\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      transaction.setTag('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      transaction.setTag('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      transaction.setTag('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    transaction.setTag('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry && _clsEntry.sources) {\n    __DEBUG_BUILD__ && logger.log('[Measurements] Adding CLS Data');\n    _clsEntry.sources.forEach((source, index) =>\n      transaction.setTag(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n", "/* eslint-disable max-lines */\nimport { getCurrentHub, hasTracingEnabled } from '@sentry/core';\nimport type { DynamicSamplingContext, Span } from '@sentry/types';\nimport {\n  addInstrumentationHandler,\n  BAGGAGE_HEADER_NAME,\n  dynamicSamplingContextToSentryBaggageHeader,\n  isInstanceOf,\n  stringMatchesSomePattern,\n} from '@sentry/utils';\n\nexport const DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\//];\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * @deprecated Will be removed in v8.\n   * Use `shouldCreateSpanForRequest` to control span creation and `tracePropagationTargets` to control\n   * trace header attachment.\n   */\n  tracingOrigins: Array<string | RegExp>;\n\n  /**\n   * List of strings and/or regexes used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * Default: ['localhost', /^\\//] {@see DEFAULT_TRACE_PROPAGATION_TARGETS}\n   */\n  tracePropagationTargets: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n}\n\n/** Data returned from fetch callback */\nexport interface FetchData {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any[]; // the arguments passed to the fetch call itself\n  fetchData?: {\n    method: string;\n    url: string;\n    // span_id\n    __span?: string;\n  };\n\n  // TODO Should this be unknown instead? If we vendor types, make it a Response\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response?: any;\n  error?: unknown;\n\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\n/** Data returned from XHR request */\nexport interface XHRData {\n  xhr?: {\n    __sentry_xhr__?: {\n      method: string;\n      url: string;\n      status_code: number;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      data: Record<string, any>;\n    };\n    __sentry_xhr_span_id__?: string;\n    setRequestHeader?: (key: string, val: string) => void;\n    getRequestHeader?: (key: string) => string;\n    __sentry_own_request__?: boolean;\n  };\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\ntype PolymorphicRequestHeaders =\n  | Record<string, string | undefined>\n  | Array<[string, string]>\n  // the below is not preicsely the Header type used in Request, but it'll pass duck-typing\n  | {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      [key: string]: any;\n      append: (key: string, value: string) => void;\n      get: (key: string) => string;\n    };\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(_options?: Partial<RequestInstrumentationOptions>): void {\n  // eslint-disable-next-line deprecation/deprecation\n  const { traceFetch, traceXHR, tracePropagationTargets, tracingOrigins, shouldCreateSpanForRequest } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = (url: string): boolean =>\n    shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', (handlerData: FetchData) => {\n      fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', (handlerData: XHRData) => {\n      xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nexport function shouldAttachHeaders(url: string, tracePropagationTargets: (string | RegExp)[] | undefined): boolean {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track fetch request spans\n */\nexport function fetchCallback(\n  handlerData: FetchData,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(handlerData.response.status);\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const currentScope = getCurrentHub().getScope();\n  const currentSpan = currentScope && currentScope.getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n\n  if (currentSpan && activeTransaction) {\n    const span = currentSpan.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch',\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    const request: string | Request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const options: { [key: string]: any } = handlerData.args[1];\n\n    if (shouldAttachHeaders(handlerData.fetchData.url)) {\n      options.headers = addTracingHeadersToFetchRequest(\n        request,\n        activeTransaction.getDynamicSamplingContext(),\n        span,\n        options,\n      );\n    }\n  }\n}\n\nfunction addTracingHeadersToFetchRequest(\n  request: string | Request,\n  dynamicSamplingContext: Partial<DynamicSamplingContext>,\n  span: Span,\n  options: {\n    headers?:\n      | {\n          [key: string]: string[] | string | undefined;\n        }\n      | Request['headers'];\n  },\n): PolymorphicRequestHeaders {\n  const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  const sentryTraceHeader = span.toTraceparent();\n\n  const headers =\n    typeof Request !== 'undefined' && isInstanceOf(request, Request) ? (request as Request).headers : options.headers;\n\n  if (!headers) {\n    return { 'sentry-trace': sentryTraceHeader, baggage: sentryBaggageHeader };\n  } else if (typeof Headers !== 'undefined' && isInstanceOf(headers, Headers)) {\n    const newHeaders = new Headers(headers as Headers);\n\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n\n    if (sentryBaggageHeader) {\n      // If the same header is appended miultiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n\n    return newHeaders as PolymorphicRequestHeaders;\n  } else if (Array.isArray(headers)) {\n    const newHeaders = [...headers, ['sentry-trace', sentryTraceHeader]];\n\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n\n    return newHeaders;\n  } else {\n    const existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    const newBaggageHeaders: string[] = [];\n\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push(...existingBaggageHeader);\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n\n    return {\n      ...(headers as Exclude<typeof headers, Headers>),\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nexport function xhrCallback(\n  handlerData: XHRData,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  if (\n    !hasTracingEnabled() ||\n    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))\n  ) {\n    return;\n  }\n\n  const xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const currentScope = getCurrentHub().getScope();\n  const currentSpan = currentScope && currentScope.getSpan();\n  const activeTransaction = currentSpan && currentSpan.transaction;\n\n  if (currentSpan && activeTransaction) {\n    const span = currentSpan.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader && shouldAttachHeaders(handlerData.xhr.__sentry_xhr__.url)) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n\n        const dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          handlerData.xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n", "import type { Transaction, TransactionContext } from '@sentry/types';\nimport { addInstrumentationHandler, logger } from '@sentry/utils';\n\nimport { WINDOW } from './types';\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function instrumentRoutingWithDefaults<T extends Transaction>(\n  customStartTransaction: (context: TransactionContext) => T | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  if (!WINDOW || !WINDOW.location) {\n    __DEBUG_BUILD__ && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl: string | undefined = WINDOW.location.href;\n\n  let activeTransaction: T | undefined;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: WINDOW.location.pathname,\n      op: 'pageload',\n      metadata: { source: 'url' },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler('history', ({ to, from }: { to: string; from?: string }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          __DEBUG_BUILD__ && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.finish();\n        }\n        activeTransaction = customStartTransaction({\n          name: WINDOW.location.pathname,\n          op: 'navigation',\n          metadata: { source: 'url' },\n        });\n      }\n    });\n  }\n}\n", "/* eslint-disable max-lines */\nimport type { Hub } from '@sentry/core';\nimport type { EventProcessor, Integration, Transaction, TransactionContext, TransactionSource } from '@sentry/types';\nimport { baggageHeaderToDynamicSamplingContext, getDomElement, logger } from '@sentry/utils';\n\nimport { startIdleTransaction } from '../hubextensions';\nimport type { IdleTransaction } from '../idletransaction';\nimport { DEFAULT_FINAL_TIMEOUT, DEFAULT_HEARTBEAT_INTERVAL, DEFAULT_IDLE_TIMEOUT } from '../idletransaction';\nimport { extractTraceparentData } from '../utils';\nimport { registerBackgroundTabDetection } from './backgroundtab';\nimport { addPerformanceEntries, startTrackingLongTasks, startTrackingWebVitals } from './metrics';\nimport type { RequestInstrumentationOptions } from './request';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request';\nimport { instrumentRoutingWithDefaults } from './router';\nimport { WINDOW } from './types';\n\nexport const BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\nexport interface BrowserTracingOptions extends RequestInstrumentationOptions {\n  /**\n   * The time to wait in ms until the transaction will be finished during an idle state. An idle state is defined\n   * by a moment where there are no in-progress spans.\n   *\n   * The transaction will use the end timestamp of the last finished span as the endtime for the transaction.\n   * If there are still active spans when this the `idleTimeout` is set, the `idleTimeout` will get reset.\n   * Time is in ms.\n   *\n   * Default: 1000\n   */\n  idleTimeout: number;\n\n  /**\n   * The max duration for a transaction. If a transaction duration hits the `finalTimeout` value, it\n   * will be finished.\n   * Time is in ms.\n   *\n   * Default: 30000\n   */\n  finalTimeout: number;\n\n  /**\n   * The heartbeat interval. If no new spans are started or open spans are finished within 3 heartbeats,\n   * the transaction will be finished.\n   * Time is in ms.\n   *\n   * Default: 5000\n   */\n  heartbeatInterval: number;\n\n  /**\n   * Flag to enable/disable creation of `navigation` transaction on history changes.\n   *\n   * Default: true\n   */\n  startTransactionOnLocationChange: boolean;\n\n  /**\n   * Flag to enable/disable creation of `pageload` transaction on first pageload.\n   *\n   * Default: true\n   */\n  startTransactionOnPageLoad: boolean;\n\n  /**\n   * Flag Transactions where tabs moved to background with \"cancelled\". Browser background tab timing is\n   * not suited towards doing precise measurements of operations. By default, we recommend that this option\n   * be enabled as background transactions can mess up your statistics in nondeterministic ways.\n   *\n   * Default: true\n   */\n  markBackgroundTransactions: boolean;\n\n  /**\n   * If true, Sentry will capture long tasks and add them to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableLongTask: boolean;\n\n  /**\n   * _metricOptions allows the user to send options to change how metrics are collected.\n   *\n   * _metricOptions is currently experimental.\n   *\n   * Default: undefined\n   */\n  _metricOptions?: Partial<{\n    /**\n     * @deprecated This property no longer has any effect and will be removed in v8.\n     */\n    _reportAllChanges: boolean;\n  }>;\n\n  /**\n   * _experiments allows the user to send options to define how this integration works.\n   * Note that the `enableLongTask` options is deprecated in favor of the option at the top level, and will be removed in v8.\n   *\n   * TODO (v8): Remove enableLongTask\n   *\n   * Default: undefined\n   */\n  _experiments: Partial<{ enableLongTask: boolean; enableInteractions: boolean }>;\n\n  /**\n   * beforeNavigate is called before a pageload/navigation transaction is created and allows users to modify transaction\n   * context data, or drop the transaction entirely (by setting `sampled = false` in the context).\n   *\n   * Note: For legacy reasons, transactions can also be dropped by returning `undefined`.\n   *\n   * @param context: The context data which will be passed to `startTransaction` by default\n   *\n   * @returns A (potentially) modified context object, with `sampled = false` if the transaction should be dropped.\n   */\n  beforeNavigate?(this: void, context: TransactionContext): TransactionContext | undefined;\n\n  /**\n   * Instrumentation that creates routing change transactions. By default creates\n   * pageload and navigation transactions.\n   */\n  routingInstrumentation<T extends Transaction>(\n    this: void,\n    customStartTransaction: (context: TransactionContext) => T | undefined,\n    startTransactionOnPageLoad?: boolean,\n    startTransactionOnLocationChange?: boolean,\n  ): void;\n}\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS: BrowserTracingOptions = {\n  idleTimeout: DEFAULT_IDLE_TIMEOUT,\n  finalTimeout: DEFAULT_FINAL_TIMEOUT,\n  heartbeatInterval: DEFAULT_HEARTBEAT_INTERVAL,\n  markBackgroundTransactions: true,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  enableLongTask: true,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n */\nexport class BrowserTracing implements Integration {\n  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented\n  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.\n  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all\n  // integrations.\n\n  /** Browser Tracing integration options */\n  public options: BrowserTracingOptions;\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = BROWSER_TRACING_INTEGRATION_ID;\n\n  private _getCurrentHub?: () => Hub;\n\n  private _latestRouteName?: string;\n  private _latestRouteSource?: TransactionSource;\n\n  public constructor(_options?: Partial<BrowserTracingOptions>) {\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options,\n    };\n\n    // Special case: enableLongTask can be set in _experiments\n    // TODO (v8): Remove this in v8\n    if (this.options._experiments.enableLongTask !== undefined) {\n      this.options.enableLongTask = this.options._experiments.enableLongTask;\n    }\n\n    // TODO (v8): remove this block after tracingOrigins is removed\n    // Set tracePropagationTargets to tracingOrigins if specified by the user\n    // In case both are specified, tracePropagationTargets takes precedence\n    // eslint-disable-next-line deprecation/deprecation\n    if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {\n      // eslint-disable-next-line deprecation/deprecation\n      this.options.tracePropagationTargets = _options.tracingOrigins;\n    }\n\n    startTrackingWebVitals();\n    if (this.options.enableLongTask) {\n      startTrackingLongTasks();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this._getCurrentHub = getCurrentHub;\n\n    const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest,\n      _experiments,\n    } = this.options;\n\n    instrumentRouting(\n      (context: TransactionContext) => this._createRouteTransaction(context),\n      startTransactionOnPageLoad,\n      startTransactionOnLocationChange,\n    );\n\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n\n    if (_experiments.enableInteractions) {\n      this._registerInteractionListener();\n    }\n\n    instrumentOutgoingRequests({\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest,\n    });\n  }\n\n  /** Create routing idle transaction. */\n  private _createRouteTransaction(context: TransactionContext): Transaction | undefined {\n    if (!this._getCurrentHub) {\n      __DEBUG_BUILD__ &&\n        logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n\n    const { beforeNavigate, idleTimeout, finalTimeout, heartbeatInterval } = this.options;\n\n    const isPageloadTransaction = context.op === 'pageload';\n\n    const sentryTraceMetaTagValue = isPageloadTransaction ? getMetaContent('sentry-trace') : null;\n    const baggageMetaTagValue = isPageloadTransaction ? getMetaContent('baggage') : null;\n\n    const traceParentData = sentryTraceMetaTagValue ? extractTraceparentData(sentryTraceMetaTagValue) : undefined;\n    const dynamicSamplingContext = baggageMetaTagValue\n      ? baggageHeaderToDynamicSamplingContext(baggageMetaTagValue)\n      : undefined;\n\n    const expandedContext: TransactionContext = {\n      ...context,\n      ...traceParentData,\n      metadata: {\n        ...context.metadata,\n        dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n      },\n      trimEnd: true,\n    };\n\n    const modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    const finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;\n\n    // If `beforeNavigate` set a custom name, record that fact\n    finalContext.metadata =\n      finalContext.name !== expandedContext.name\n        ? { ...finalContext.metadata, source: 'custom' }\n        : finalContext.metadata;\n\n    this._latestRouteName = finalContext.name;\n    this._latestRouteSource = finalContext.metadata && finalContext.metadata.source;\n\n    if (finalContext.sampled === false) {\n      __DEBUG_BUILD__ &&\n        logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    __DEBUG_BUILD__ && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n\n    const hub = this._getCurrentHub();\n    const { location } = WINDOW;\n\n    const idleTransaction = startIdleTransaction(\n      hub,\n      finalContext,\n      idleTimeout,\n      finalTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n      heartbeatInterval,\n    );\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      addPerformanceEntries(transaction);\n    });\n\n    return idleTransaction as Transaction;\n  }\n\n  /** Start listener for interaction transactions */\n  private _registerInteractionListener(): void {\n    let inflightInteractionTransaction: IdleTransaction | undefined;\n    const registerInteractionTransaction = (): void => {\n      const { idleTimeout, finalTimeout, heartbeatInterval } = this.options;\n\n      const op = 'ui.action.click';\n      if (inflightInteractionTransaction) {\n        inflightInteractionTransaction.finish();\n        inflightInteractionTransaction = undefined;\n      }\n\n      if (!this._getCurrentHub) {\n        __DEBUG_BUILD__ && logger.warn(`[Tracing] Did not create ${op} transaction because _getCurrentHub is invalid.`);\n        return undefined;\n      }\n\n      if (!this._latestRouteName) {\n        __DEBUG_BUILD__ &&\n          logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n        return undefined;\n      }\n\n      const hub = this._getCurrentHub();\n      const { location } = WINDOW;\n\n      const context: TransactionContext = {\n        name: this._latestRouteName,\n        op,\n        trimEnd: true,\n        metadata: {\n          source: this._latestRouteSource || 'url',\n        },\n      };\n\n      inflightInteractionTransaction = startIdleTransaction(\n        hub,\n        context,\n        idleTimeout,\n        finalTimeout,\n        true,\n        { location }, // for use in the tracesSampler\n        heartbeatInterval,\n      );\n    };\n\n    ['click'].forEach(type => {\n      addEventListener(type, registerInteractionTransaction, { once: false, capture: true });\n    });\n  }\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | null {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  const metaTag = getDomElement(`meta[name=${metaName}]`);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return metaTag ? metaTag.getAttribute('content') : null;\n}\n", "/** The status of an Span.\n *\n * @deprecated Use string literals - if you require type casting, cast to SpanStatusType type\n */\n// eslint-disable-next-line import/export\nexport enum SpanStatus {\n  /** The operation completed successfully. */\n  Ok = 'ok',\n  /** Deadline expired before operation could complete. */\n  DeadlineExceeded = 'deadline_exceeded',\n  /** 401 Unauthorized (actually does mean unauthenticated according to RFC 7235) */\n  Unauthenticated = 'unauthenticated',\n  /** 403 Forbidden */\n  PermissionDenied = 'permission_denied',\n  /** 404 Not Found. Some requested entity (file or directory) was not found. */\n  NotFound = 'not_found',\n  /** 429 Too Many Requests */\n  ResourceExhausted = 'resource_exhausted',\n  /** Client specified an invalid argument. 4xx. */\n  InvalidArgument = 'invalid_argument',\n  /** 501 Not Implemented */\n  Unimplemented = 'unimplemented',\n  /** 503 Service Unavailable */\n  Unavailable = 'unavailable',\n  /** Other/generic 5xx. */\n  InternalError = 'internal_error',\n  /** Unknown. Any non-standard HTTP status code. */\n  UnknownError = 'unknown_error',\n  /** The operation was cancelled (typically by the user). */\n  Cancelled = 'cancelled',\n  /** Already exists (409) */\n  AlreadyExists = 'already_exists',\n  /** Operation was rejected because the system is not in a state required for the operation's */\n  FailedPrecondition = 'failed_precondition',\n  /** The operation was aborted, typically due to a concurrency issue. */\n  Aborted = 'aborted',\n  /** Operation was attempted past the valid range. */\n  OutOfRange = 'out_of_range',\n  /** Unrecoverable data loss or corruption */\n  DataLoss = 'data_loss',\n}\n", "import { addExtensionMethods } from './hubextensions';\nimport * as Integrations from './integrations';\n\nexport type { RequestInstrumentationOptions } from './browser';\nexport type { SpanStatusType } from './span';\n\nexport { Integrations };\n\n// This is already exported as part of `Integrations` above (and for the moment will remain so for\n// backwards compatibility), but that interferes with treeshaking, so we also export it separately\n// here.\n//\n// Previously we expected users to import tracing integrations like\n//\n// import { Integrations } from '@sentry/tracing';\n// const instance = new Integrations.BrowserTracing();\n//\n// This makes the integrations unable to be treeshaken though. To address this, we now have\n// this individual export. We now expect users to consume BrowserTracing like so:\n//\n// import { BrowserTracing } from '@sentry/tracing';\n// const instance = new BrowserTracing();\n//\n// For an example of of the new usage of BrowserTracing, see @sentry/nextjs index.client.ts\nexport { BrowserTracing, BROWSER_TRACING_INTEGRATION_ID } from './browser';\n\nexport { Span, spanStatusfromHttpCode } from './span';\n// eslint-disable-next-line deprecation/deprecation\nexport { SpanStatus } from './spanstatus';\nexport { Transaction } from './transaction';\nexport { instrumentOutgoingRequests, defaultRequestInstrumentationOptions } from './browser';\nexport { IdleTransaction } from './idletransaction';\nexport { startIdleTransaction } from './hubextensions';\n\n// Treeshakable guard to remove all code related to tracing\ndeclare const __SENTRY_TRACING__: boolean;\n\n// Guard for tree\nif (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {\n  // We are patching the global object with our hub extension methods\n  addExtensionMethods();\n}\n\nexport { addExtensionMethods };\n\nexport {\n  extractTraceparentData,\n  getActiveTransaction,\n  // eslint-disable-next-line deprecation/deprecation\n  hasTracingEnabled,\n  stripUrlQueryAndFragment,\n  TRACEPARENT_REGEXP,\n} from './utils';\n"],
  "mappings": "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",
  "names": ["hasTracingEnabled", "_hasTracingEnabled", "SpanClass", "getCurrentHub", "getCurrentHub", "getCurrentHub", "getCurrentHub", "getCurrentHub", "span", "getCurrentHub", "getCurrentHub", "getCurrentHub", "orig", "performance", "shouldAttachHeaders", "getCurrentHub", "SpanStatus"]
}
